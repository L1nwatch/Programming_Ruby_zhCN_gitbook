Ruby 和其他语言的一个不同之处就是任何东西都能返回一个值：几乎所有东西都是表达式。

明显的一个好处是能够实现链式语句。

```ruby
a = b = c = 0				# ->	0
[3, 1, 7, 0].sort.reverse	# ->	[7, 3, 1, 0]
```

不太明显的好处是，C 和 Java 中的普通语句在 Ruby 中也是表达式。例如，if 和 case 语句都返回最后执行的表达式的值。

### 7.1 运算符表达式

实际上，Ruby 中的许多运算符都是由方法调用来实现的。例如，当你执行 `a*b+c` 时，等价于：

```ruby
(a.*(b)).+(c)
```

你可以重新定义任何不满足你需求的基本算术方法：

```ruby
class Fixnum
  alias old_plus +
    def +(ohter)
      old_plus(other).succ
    end
end
```

更有用的是，你写的类可以像內建对象那样参数到运算符表达式中：

```ruby
class Songe
  def [](from_time, to_time)
    # ...
  end
end
```

### 7.2 表达式之杂项

#### 7.2.1 命令展开

如果你用反引号（\`），或者以 `%x` 为前缀的分界形式，括起一个字符串，默认情况下它会被当做底层操作系统的命令来执行。表达式的返回值就是该命令的标准输出。你获得的返回值结尾可能会有回车符或者换行符。

你也可以在命令字符串中使用表达式展开和所有普通的转义序列。

```ruby
for i in 0..3
  status = 'dbmanager status id=#{1}'
  # ...
end
```

命令的退出状态（exit status）保存在全局变量 `$?` 中。

##### 重定义反引号

我们说反括号括起的字符串“默认”被当做命令来执行。实际上，字符串被传递给了名为 Kernel.\` 方法（单反引号）。如果你愿意，可以重载它。

```ruby
alias old_backquote `
def `(cmd)
  result = old_backquote(cmd)
  if $? != 0
    fail "Command #{cmd} failed: #$?"
  end
  result
end
```

### 7.3 赋值

赋值语句将左侧的变量或者属性（左值）设置为右侧的值（右值），然后返回该值作为赋值表达式的结果。这意味着你可以链接赋值语句，并可以在某些特殊的地方执行赋值操作。

```ruby
a = b = 1 + 2 + 3
# a ->	6
# b	->	6
a = (b = 1 + 2) + 3
# a ->	6
# b ->	3
File.open(name = gets.chomp)
```

Ruby 的赋值语句有两种形式。第一种是将一个对象引用赋值给变量或者常量。这种形式的赋值在 Ruby 语言中是直接执行的（hardwired）。

第二种形式等号左边是对象属性或者元素的引用。

```ruby
song.duration = 234
instrument["ano"] = "ccolo"
```

这种形式的特殊之处在于，它是通过调用左值的方法来实现的，这意味着你可以重载它们。只要简单地定义一个以等于号结尾的方法即可。这个方法以其右值作为它的参数。

这种设置属性的方法不必和内部的实例变量相对应，并且具有赋值方法的属性也并非必须要有读取该属性的方法。

```ruby
class Amplifier
  def volume=(new_volume)
    self.left_channel = self.right_channel = new_volume
  end
end
```

在老版本的 Ruby 中（低于 Ruby1.8），赋值语句的返回值是设置该属性的方法的返回值。在 Ruby 1.8 中，赋值语句的值总是参数的值而方法的返回值将被丢掉。

```ruby
class Test
  def val=(val)
    @val = val
    return 99
  end
end
t = Test.new
a = t.val = 2
a # -> 2
```

#### 7.3.1 并行赋值

Ruby 的赋值实际是以并行方式执行的，所以赋值语句右边的值不受赋值语句本身的影响。在左边的任意一个变量或属性被赋值之前，右边的值按它们出现的顺序被计算出来。

当赋值语句有多于一个左值时，赋值表达式将返回由右值组成的数组。如果赋值语句的左值多于右值，那么多余的左值将被忽略。如果右值多于左值，那么额外的右值将被忽略。如果赋值语句仅有一个左值，而有多个右值，那么右值将被转换成数组，然后赋值给左值。

>   ##### 在类中使用访问方法
>
>   可写属性有个隐藏的陷阱。通常，类中的方法可以通过函数形式（即带一个隐式 self 作为接受者）调用同一个类的其他方法和它的父类的方法。然而这不适用于属性赋值函数：Ruby 看到赋值语句时，会认为左边的名字是局部变量，而不是为一个属性赋值的方法调用。
>
>   ```ruby
>   class BrokenAmplifier
>     attr_accessor :left_channel, :right_channel
>     def volume=(vol)
>       # 注意 left_channel 仅仅是局部变量，这个赋值不会影响到 self.left_channel
>       left_channel = self.right_channel = vol
>     end
>   end
>   ```

使用 Ruby 的并行赋值操作，你可以叠起和展开数组：

```ruby
a = [1, 2, 3, 4]
b, c = a		# ->	b = 1, c = 2
b, *c = a		# ->	b = 1, c = [2, 3, 4]
b, c = 99, a	# ->	b = 99, c = [1, 2, 3, 4]
b, *c = 99, a	# ->	b = 99, c = [[1, 2, 3, 4]]
b, c = 99, *a	# ->	b = 99, c = 1
b, *c = 99, *a	# ->	b = 99, c = [1, 2, 3, 4]
```

##### 嵌套赋值

并行赋值还有一个值得一提的特性：赋值语句的左边可以含有一个由括号括起来的变量列表。Ruby 视这些变量为嵌套赋值语句。在处理更高层级的赋值语句前，Ruby 会提取出对应的右值，并赋值给括起来的变量。

```ruby
b, (c, d), e = 1, 2, 3, 4			# ->	b = 1, c = 2, d = nil, e = 3
b, (c, d), e = [1, 2, 3, 4]			# ->	b = 1, c = 2, d = nil, e = 3
b, (c, d), e = 1, [2, 3], 4			# ->	b = 1, c = 2, d = 3, e = 4
b, (c, d), e = 1, [2, 3, 4], 5		# ->	b = 1, c = 2, d = 3, e = 5
b, (c, *d), e = 1, [2, 3, 4], 5		# ->	b = 1, c = 2, d = [3, 4], e = 5
```

#### 7.3.2 赋值语句的其他形式

