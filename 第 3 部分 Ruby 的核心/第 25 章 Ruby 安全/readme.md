Ruby 为减少安全风险提供了支持。所有来自外部的数据都可以标记为被污染的（tained，或不受信的）。当运行在安全模式下时，传递被污染的对象给一个具有潜在威胁的方法会引发 `SecurityError`。

### 25.1 安全级别

变量 `$SAFE` 决定了 Ruby 的安全级别。

| `$SAFE` | 限制                              |
| ------- | ------------------------------- |
| 0       | 对外部提供（受污染）的数据不做检查。这是 Ruby 的默认模式 |
| \>=1    | Ruby 不允许在具有潜在威胁的操作中使用受污染的数据     |
| \>=2    | Ruby 禁止从外部可写的位置装载程序文件           |
| \>=3    | 所有新创建的对象都被认为受污染了                |
| \>=4    | Ruby 有效地将运行的程序分为两部分。未污染的对象不能被修改 |

如果 Ruby 运行 `setuid` 或 `setgid` 的脚本，或者在 `mod_ruby` 下执行，它的安全级别会自动变为 1。安全级别还可以通过 `-T` 命令行选项设置，也可以通过在程序中对 `$SAFE` 重新赋值来设置。但是通过对 `$SAFE` 赋值不能降低其值的大小。

当创建新的线程时，`$SAFE` 的当前值被继承下来。然而，在每个线程中，可以修改 `$SAFE` 的值而不影响其他线程中该变量的值。使用这种特性可以实现安全“沙箱”。

```ruby
f = open(filename, "w")
f.print "..."
f.close
Thread.start do
  $SAFE = 4
  load(filename, true)
end
```

当创建 Proc 对象时，实际的安全级别被存储在该对象中。如果 Proc 被污染了，且当前的安全级别大于创建 block 时的实际级别，则 Proc 不能作为参数传递给方法。

### 25.2 受污染的对象

任何从外部资源（例如从文件中读取的字符串或环境变量）派生的 Ruby 对象都被自动标记为受污染。如果程序从受污染的对象中派生了一个新的对象，那么这个新对象也将被污染。以前在某个位置获得外部数据的对象也将被污染。不管当前的安全级别是什么，此污染判断过程总会被执行。使用 `Object#tained?` 方法可以看到一个对象是否已被污染。

`taint` 方法可以把任意对象强制转换成受污染的对象。如果安全级别低于 3，`untaint` 方法可以把对象的受污染标记去除。轻易不能做这种操作。

